# -*- coding: utf-8 -*-
# The easiest way to make REST apis in Python is usually to use flask.
# You can use Django if you want too, but it's heavier, and this will get the job done fine (and help you understand more about what it is that's going on).
from flask import Flask, request
from bson.json_util import dumps
from functools import wraps
import ast
import json
import asyncio
from operator import xor as either
from bson import ObjectId
from time import sleep
from datetime import datetime
import random
from pymongo import MongoClient
from apscheduler.schedulers.background import BackgroundScheduler
import atexit
from logging import debug
import onesignal as onesignal_sdk
from copy import copy

app = Flask(__name__)
# connectionstring = 'mongodb+srv://admin:W05BiKav@rpglitestorage-hnw6v.mongodb.net/test?retryWrites=true&w=majority'
connectionstring = 'mongodb://takuu.dcs.gla.ac.uk:27017'
client = MongoClient(connectionstring)
database_name = "Game_data"
db = client[database_name]
players = db["players"]
games = db["games"]
completed_games = db["completed_games"]
player_backup = db["player_backup"]
games_backup = db['games_backup']
page_hits = db['page_hits']
special_data = db['special_data']
dereferenced_games = db['dereferenced_games']

onesignal_client = onesignal_sdk.Client(user_auth_key="M2MwNWFiOTEtMjNhMy00NjBiLTk1OTUtYzY5MTQyMDA3ZWNl",
                                        app_auth_key="YjVmMjE4MDgtZGQ1Ni00Yjc5LWI1MjAtZmFiZjkxNDU3MTNl",
                                        app_id="456e9cc8-ff3b-4102-9924-abe478290a26")


MIDDLEWARE_VERSION = "1.2"
MIDDLEWARE_CHANGESET = "New and improved balance of character strengths"

RPGLITE_CURR_BALANCE = '1.2'  # Tango 2.3

CHARACTER_ORDERING = ['K', 'A', 'R', 'H', 'W', 'B', 'M', 'G']
MAX_HEALTHS = [10, 9, 8, 9, 8, 9, 7, 8]  # Tango 2.3
BADGE_INFO_SPACES = 50  # More just in case we want to expand in the future. We use this when registering new users.
LOGIN_SKILL_DELTA = 10

COLLECTIONS_TO_BACKUP = [players]
BACKUP_LOCATIONS = [(players, player_backup),
                    (games, games_backup)]
BACKUP_FREQUENCY_SECS = 60 * 60

BADGE_CONSECUTIVE_LOGINS = 17
BADGE_SKILL_POINT_MAX = 19
BADGE_SKILL_MORE = 20
BADGE_SKILL_LESS = 21
BADGE_LONGEST_WIN_STREAK = 22
BADGE_PERCENTILE_REACHED = 24
BADGE_NUM_TIMES_ALL_CHARS_PLAYED = 25
BADGE_PLAY_X_GAMES = 26
BADGE_PLAY_WITH_SINGLE_CHAR = 27
BADGE_WIN_X_WITH_CHAR_AT_FULL = 28
BADGE_WIN_X_WITH_1_HEALTH = 29
BADGE_WIN_X_IN_UNDER_1H = 30
BADGE_ACCEPT_X_CHALLENGES = 31  ### TODO: accept x challeges
BADGE_PLAY_X_NEW = 32  ### TODO: play x new
BADGE_MATCHMAKE_FROM_WAITING = 33
BADGE_CHALLENGES_POSTED = 34
BADGE_NIGHT_OWL = 35
BADGE_VENGEANCE = 36
BADGE_EXPLORER = 37
BADGE_PERSISTENT = 38  # NOTE: this also uses slot 39!
BADGE_EAGER_BEAVER = 16
BADGE_ACTIVE_USERS = 40
BADGE_SEASONAL_SKILL_POINT_MAX = 41
BADGE_SEASONAL_SKILL_MORE = 42
BADGE_SEASONAL_SKILL_LESS = 43


LOCK_QUEUE = 1
LOCK_DEQUEUE = 2
LOCK_REGISTER = 3
LOCK_GAME_OVER = 4  # No longer used; LOCK_TAKE_TURN to be used instead.
LOCK_LOGIN = 5
LOCK_TAKE_TURN = 4
TESTLOCK = 40

ELO_DEFAULT = 1200
ELO_K=10



def response_builder(action, *args, **kwargs):
    def inner_closure(*args, **kwargs):
        try:
            try:
                body = ast.literal_eval(json.dumps(request.get_json()))

            except:
                # Error; couldn't get the body of the request.
                return "Bad request, couldn't parse", 400

            return action(body, *args, **kwargs)

        except:
            # Something went wrong, but this is too generic to work out what might have happened.
            return "Server error from autogenerated endpoint", 500

    return inner_closure


def lock(locknum=None):
    MAXIMUM_LOCK_DURATION = 2.5  # Seconds
    def requires_lock(func):
        @wraps(func)
        def lock_aquiring_function(*args, **kwargs):
            has_lock = False
            standoff_delay = 0.005
            my_lock = random.random()

            def lockval(lock):
                existing_lock = lock['default_lock'] if locknum is None else lock['specific_locks'][locknum]
                if not isinstance(existing_lock, list):
                    setlock(lock, existing_lock)  # Make sure the type is right.
                    return existing_lock, datetime.now()
                existing_value = existing_lock[0]
                time_value_was_posted = existing_lock[1]
                return existing_value, time_value_was_posted

            def setlock(lock, val):
                if locknum is None:
                    lock['default_lock'] = [val, datetime.now()]
                else:
                    lock['specific_locks'][locknum] = [val, datetime.now()]

            print(my_lock)
            while not has_lock:
                posted_lock = players.find_one({"mutex_lock": {"$exists": True}})
                existing_value, time_value_was_posted = lockval(posted_lock)
                while existing_value is not None and (datetime.now() - time_value_was_posted).seconds < MAXIMUM_LOCK_DURATION:
                    if (time_value_was_posted - datetime.now()).seconds < MAXIMUM_LOCK_DURATION:
                        print("Stealing for timeout")
                    sleep(standoff_delay)
                    print(str(my_lock) + ':\twaiting...')
                    posted_lock = players.find_one({"mutex_lock": {"$exists": True}})
                    existing_value, time_value_was_posted = lockval(posted_lock)
                setlock(posted_lock, my_lock)
                players.replace_one({"_id": posted_lock['_id']}, posted_lock)
                sleep(0.05)
                new_lock_doc = players.find_one({'mutex_lock': {"$exists": True}})
                if lockval(new_lock_doc)[0] != my_lock:
                    print(str(my_lock) + ':\tstanding off')
                    standoff_delay *= 2
                else:
                    print(str(my_lock) + ':\tgot lock!')
                    has_lock = True

            return_val = func(*args, **kwargs)
            setlock(posted_lock, None)
            players.replace_one({"mutex_lock": {'$exists': True}}, posted_lock)
            print('replaced lock.')
            return return_val

        return lock_aquiring_function

    return requires_lock


@app.route('/exists/<username>')
def check_username(username):
    return str(players.find_one({'Username': username}) is not None), 200


@app.route('/waitinglist')
@lock(LOCK_QUEUE)
def waiting_list():
    if players.find_one({"waiting_list": True, "waiting": None}) is not None:
        return "no", 200
    wl = players.find_one({"waiting_list": True})
    waiting_id = wl["waiting"]
    return str(players.find_one({"_id": waiting_id})["Username"]), 200


@app.route('/check_game/<game_id>')
def check_game(game_id):
    # Find the usernames for a game and the state of play
    game = games.find_one({'_id': ObjectId(game_id)})
    if game is None:
        return "Couldn't get game", 410
    p1 = players.find_one({'_id': game["p1"]})
    p2 = players.find_one({'_id': game["p2"]})
    return_dict = {"p1": p1['Username'],
                   "p2": p2['Username'], "p1_selected": game["p1_selected"],
                   "p2_selected": game["p2_selected"], "p1_turn": game["p1_turn"],
                   'p1_skill': int(p1.get('skill_points', -1)),
                   'p2_skill': int(p2.get('skill_points', -1)),
                   'active_player': game.get('active_player', p1["Username"]),
                   'activity_in_last_day': (datetime.now() - game.get('most recent activity', [datetime.now()])[0]).days < 1}
    return return_dict, 200


@app.route('/login', methods=["PUT"])
@lock(LOCK_LOGIN)
def login():
    # Wallacian magic to get inner whatever.
    try:
        try:
            print('enter')
            body = ast.literal_eval(json.dumps(request.get_json()))
            player = players.find_one({'Username': body["cred_username"], 'Password': body["cred_hashed_pw"]})

            reset_keys = special_data.find_one({'password_reset_keys': {'$exists': True}})
            stored_key = reset_keys.get(player["Username"], None)

            print('got user')
            # If the user hasn't logged in yet today, give them 10 points.
            first_login_today = player['last_logged_in'].date() < datetime.today().date()
            if player['last_logged_in'].date() < datetime.today().date():
                player['skill_points'] = player.get('skill_points', 0) + LOGIN_SKILL_DELTA
                player['current_season_skill'] = player.get('current_season_skill', 0) + LOGIN_SKILL_DELTA
                update_skill_point_max_badge(player)

            if 'count_character_has_won' not in player:
                player['count_character_has_been_played'] = {char: count for char, count in zip(CHARACTER_ORDERING,
                                                                                                player[
                                                                                                    'badge_progressions'][
                                                                                                0:16:2])}
                player['count_character_has_won'] = {char: count for char, count in
                                                     zip(CHARACTER_ORDERING, player['badge_progressions'][1:17:2])}

            print('updated skill point badges')
            update_night_owl_badge(player)
            print('updated night owl badge')
            
            print("updating active users list")
            update_active_users_list(player)
            print("updated active users list")

            delta_days = (datetime.now() - player['last_logged_in']).days
            if delta_days == 1:
                player['badge_progressions'][BADGE_CONSECUTIVE_LOGINS + 1] += 1

                if player['badge_progressions'][BADGE_CONSECUTIVE_LOGINS] == player['badge_progressions'][BADGE_CONSECUTIVE_LOGINS + 1] - 1:
                    player['badge_progressions'][BADGE_CONSECUTIVE_LOGINS] += 1

            elif delta_days > 1:
                player['badge_progressions'][BADGE_CONSECUTIVE_LOGINS + 1] = 1

            print('updated consecutive logins')

            player['last_logged_in'] = datetime.today()

            players.replace_one({'Username': player['Username']}, player)

            # log_datapoint('login', player['Username'])

            print('replaced player data')
            # return dumps(player), 200
            return {'player': dumps(player), 'first_today': first_login_today, "magickey": stored_key}, 200


        except:
            # Error; couldn't get the body of the request.
            return "Bad request, couldn't parse", 400

        # return action(body, *args, **kwargs)

    except:
        # Something went wrong, but this is too generic to work out what might have happened.
        return "Server error from autogenerated endpoint", 500


# Receives JSON with player, game and char choices.
# updates game doc appropriately, if both have selected then chooses who goes first.
@app.route('/choice', methods=["PUT"])
def choice():
    try:
        body = ast.literal_eval(json.dumps(request.get_json()))  # game_id, user_id, card1, card2
        game = games.find_one({"_id":ObjectId(body["game_id"]["$oid"])})
        player_str = "p2"
        if game["p1"] == ObjectId(body["user_id"]["$oid"]):
            player_str = "p1"
        game[player_str + "_selected"] = True
        game[player_str + "c1"] = body["card1"]
        game[player_str + "c2"] = body["card2"]
        game["most recent activity"] = [datetime.now(), player_str]
        # Set health initially, fixed on turn 1.
        game["p1c1_health"] = 99
        game["p1c2_health"] = 99
        game["p2c1_health"] = 99
        game["p2c2_health"] = 99
        game["usernames"] = []
        [game["usernames"].append(players.find_one({"_id": game[player]})["Username"]) for player in ["p1", "p2"]]
        if game["p1_selected"] and game["p2_selected"]:
            game["p1_turn"] = random.choice([True, False])
            game["start_time"] = datetime.now()
            game["active_player"] = game["usernames"][0] if game["p1_turn"] else game["usernames"][1]
        # else:
        #     send_notification(game['usernames'][1 if player_str == "p1" else 0], "Choose your characters!", "New game! You have some characters to select!")
        # push update
        games.replace_one({"_id":ObjectId(body["game_id"]["$oid"])}, game)
        return "True",200

    except Exception as e:
        print(e)
        return "Bad request, couldn't parse", 400



@app.route('/queue', methods=["PUT"])
@lock(LOCK_QUEUE)
def queue():
    # Wallacian magic to get inner whatever.
    try:
        try:
            body = ast.literal_eval(json.dumps(request.get_json()))
            waiting_list = players.find_one({"waiting_list": True})

            queuer = players.find_one({"_id": ObjectId(body["_id"]["$oid"])})

            # Fail if somebody is already waiting
            print(waiting_list)
            print(body)
            print(str(waiting_list["waiting"]))
            if waiting_list["waiting"] is not None and waiting_list["waiting"] != ObjectId(body["_id"]["$oid"]):
                print(4)
                return "Somebody already queued; should have matched instead.", 400
            elif waiting_list["waiting"] == ObjectId(queuer['_id']) or queuer["Games"][body["slot"]] != "none":
                print(5)
                return "You're already in the queue", 400

            queue_request = {"waiting_list": True, "waiting": ObjectId(body["_id"]["$oid"]), "slot": body["slot"]}
            players.replace_one(waiting_list, queue_request)
            queuer = players.find_one({"_id": ObjectId(body["_id"]["$oid"])})
            # reset previous waiting slot, then update correct slot.
            for i in range(len(queuer["Games"])):
                if queuer["Games"][i] == "waiting":
                    queuer["Games"][i] = "none"
            queuer["Games"][body["slot"]] = "waiting"
            players.replace_one({"_id": ObjectId(body["_id"]["$oid"])}, queuer)
            return dumps(queuer), 200

        except Exception as e:
            # Error; couldn't get the body of the request.
            print(e)
            return "Bad request, couldn't parse: " + str(e), 400

        # return action(body, *args, **kwargs)
    except:
        # Something went wrong, but this is too generic to work out what might have happened.
        return "Server error from autogenerated endpoint", 500


@app.route('/dequeue', methods=["PUT"])
@lock(LOCK_QUEUE)
def dequeue():
    # Wallacian magic to get inner whatever.
    try:
        try:
            body = ast.literal_eval(json.dumps(request.get_json()))
            username = body["username"]
            slot = body["slot"]
            waiting_list = players.find_one({"waiting_list": True})

            if waiting_list["waiting"] is None:
                return "Nobody to dequeue", 400

            queue_request = {"waiting_list": True, "waiting": None, "slot": None}
            players.replace_one(waiting_list, queue_request)
            user = players.find_one({"Username": username})
            user["Games"][slot] = "none"
            players.replace_one({"Username": username}, user)
            return dumps(user), 200

        except:
            # Error; couldn't get the body of the request.
            return "Bad request, couldn't parse", 400

        # return action(body, *args, **kwargs)

    except:
        # Something went wrong, but this is too generic to work out what might have happened.
        return "Server error from autogenerated endpoint", 500


@app.route('/find_opp', methods=["PUT"])
def find_opp():
    # Wallacian magic to get inner whatever.
    try:
        try:
            body = ast.literal_eval(json.dumps(request.get_json()))
            # host, target, slot
            # return "true", "full", 'rejecting' or "not found"
            target = players.find_one({'Username': body["target"]})
            if target is None:
                # No player found
                return "none", 200
            if not target.get('accepting_games', True):
                return 'rejecting'
            if "none" not in target["Games"]:
                # Opponent has no space to find you
                return "full", 200
            # We're good, let's do this
            host = players.find_one({"Username": body["host"]})
            slot = body["slot"]
            new_game = {
                "p1": ObjectId(host["_id"]),
                "p2": ObjectId(target["_id"]),
                "p1_selected": False,
                "p2_selected": False,
                "p1_turn": False,
                "Moves": [],
                "active_player": "none",
                "most recent activity": [datetime.now(), target['Username']],
                "balance_code": RPGLITE_CURR_BALANCE
            }

            # Update relevant badges
            host = update_badges_chosen_from_lists(host, target['Username'])

            games.insert_one(new_game)
            new_game_id = games.find_one(new_game)["_id"]

            # UPDATE host PLAYER'S GAMES []
            host["Games"][slot] = new_game_id
            players.replace_one({"Username": body["host"]}, host)

            # UPDATE target PLAYER'S GAMES []
            slot = 0
            for i in range(5):
                if target["Games"][i] == "none":
                    slot = i
                    break
            target["Games"][slot] = new_game_id
            players.replace_one({"Username": body["target"]}, target)

            send_new_match_notification(target['Username'], host['Username'])

            # Return success
            return dumps(host), 200


        except Exception as e:
            print(e)
            # Error; couldn't get the body of the request.
            return "Bad request, couldn't parse: " + str(e), 400

    except:
        print(e)
        # Something went wrong, but this is too generic to work out what might have happened.
        return "Server error from autogenerated endpoint", 500

@app.route("/test_notification/<reciever>/<opponent>")
def send_new_match_notification(reciever, opponent):
    send_notification(reciever, "New RPGLite match!", build_new_match_notification_text(reciever, opponent))

def build_new_match_notification_text(reciever, opponent):
    opp_doc = players.find_one({"Username": opponent})
    rec_doc = players.find_one({"Username": reciever})

    rec_seeking_vengeance = opponent in rec_doc.get('lost_against', [])
    opp_seeking_vengeance = reciever in opp_doc.get('lost_against', [])

    messages_to_choose_from = ["You have a new match against " + opponent + "!",
                               opponent + " thinks they can challenge...wait. That's YOU! Show them the error of their ways.",
                               "Can you believe " + opponent + " thinks they can challenge " + reciever +
                               "?! Wait...that's you? Oh. I think you have some characters to select!",
                               "There's a legend written on an ancient parchment that a new age begins when " +
                               opponent + " challenges " + reciever +
                               ". (That's you) (You have a new match now)",
                               "HELLO. FRIENDLY RPGLITE HUMAN HERE AND NOT A COMPUTER. " + opponent +
                               " HAS CHALLENGED YOU TO ONE OF YOUR HUMAN GAMES. I MEAN GAMES.",
                               "Next into the arena is " + reciever +
                               ", squaring up against their new nemesis, " + opponent + "...",
                               "Hi! RPGLite developers here. Yeah... sorry this notification wasn't a text or something, but please play our cool and good game!",
                               "Listen. I'll be honest. It's surprising you read these notification messages anyway, and I can't think of any more! You have a new match against " + opponent + ", OK?",
                               "Three things in life are certain, but the only exciting one is that you have a new game against " + opponent + ".",
                               "🎵Gaaaaaaammmmmmeeesssssssssss......you have a feewwwwwwwwwwwwwww🎵",
                               "We interrupt your day to bring you the following message: " +
                               opponent + " has made a new game against you.",
                               "",
                               "Them? Again?!",
                               "🎲🕹👾",
                               "🎼When their knight hits your eye but your healer's nearby that's rpgliiiitteeeeee......🎶",
                               "Usually we try to put something funny here, but: thanks for playing this game. It's not words with friends, sure, but we're proud of it and excited for the research you're helping us to do. Thank you.",
                               ]

    if rec_seeking_vengeance:
        messages_to_choose_from.append(opponent + " just made a new match against you. You've lost against them recently — want some vengeance?")
        messages_to_choose_from.append(opponent + " seems to think they can beat you again. Go ahead and show them it was just the luck of the dice...")

    if opp_seeking_vengeance:
        messages_to_choose_from.append(opponent + " just made a new game against you, and they've lost to you recently! Best of three?")
        messages_to_choose_from.append(opponent + " just made a new game against you. Maybe they've just come back looking for that dignity they left before?")
        messages_to_choose_from.append(opponent + " has made a new game against you. They lost against you recently — what makes them think this will be different?")

    return random.choice(messages_to_choose_from)

# Take username, return list of games.
@app.route('/get_games/<username>')
def get(username):
    # Wallacian magic to get inner whatever.
    try:
        user = players.find_one({"Username": username})
        return dumps(user["Games"]), 200

    except:
        # Error; couldn't get the body of the request.
        return "Bad request, couldn't parse", 400


# Takes user and slot of game to abandon.
# removes game from user, does not increment user played.
# adds pX_abandon = true to the game.
@app.route('/abandon', methods=["PUT"])
@lock(LOCK_TAKE_TURN)
def abandon():
    try:
        body = ast.literal_eval(json.dumps(request.get_json()))
        username = body["username"]
        slot = body["slot"]
        user = players.find_one({"Username": username})  # user abandoning
        abandon_game_id = user["Games"][slot]
        abandoned_game = games.find_one({"_id": abandon_game_id})  # game being abandoned
        user["Games"][slot] = "none"
        opponent = players.find_one(
            {'_id': abandoned_game['p2'] if abandoned_game['p1'] == user['_id'] else abandoned_game['p1']})
        players.replace_one({"Username": username}, user)  # game removed from user
        player_num = 1 if user["_id"] == abandoned_game["p1"] else 2
        if player_num == 1:
            abandon_str = "p1_abandon"
        else:
            abandon_str = "p2_abandon"

        delta = 0

        if not abandoned_game['p1_selected'] or not abandoned_game['p2_selected']:
            for i in range(5):
                print(opponent['Games'][i], '\t', abandon_game_id)
                if str(opponent['Games'][i]) == str(abandon_game_id):
                    print("REMOVED")
                    opponent['Games'][i] = 'none'
                    players.replace_one({"Username": opponent['Username']}, opponent)

            games.delete_one({"_id": abandon_game_id})
            
            move_game_to_completed(abandoned_game)
            return {'user': dumps(user), 'delta': delta}, 200

        if 'most recent activity' in abandoned_game:
            # if it's been less than a day, or more than a day and your turn, you lose
            if (datetime.now() - abandoned_game['most recent activity'][0]).days < 1 or \
                    abandoned_game["active_player"] != opponent["Username"]:
                delta = calc_delta(user['current_season_skill'],
                                   opponent['current_season_skill'],
                                   False)
                user['skill_points'] = max((user['skill_points']//100)*100, user['skill_points'] + delta)
                user['current_season_skill'] = max((user['current_season_skill']//100)*100, user['current_season_skill'] + delta)
                calculate_new_elo(opponent, user)
                move_game_to_completed(abandoned_game)
            elif abandoned_game['active_player'] == opponent["Username"]:
                # if more than a day and the other person's turn, you win
                delta = calc_delta(user['current_season_skill'],
                                   opponent['current_season_skill'],
                                   True)
                user['skill_points'] = max((user['skill_points']//100)*100, user['skill_points'] + delta)
                user['current_season_skill'] = max((user['current_season_skill']//100)*100, user['current_season_skill'] + delta)

                # TODO: Dereference from opponent (claim victory)
                opponent['Games'] = [game if game != abandoned_game['_id'] else 'none' for game in opponent['Games']]
                players.replace_one({"Username": user["Username"]}, user)
                players.replace_one({"Username": opponent["Username"]}, opponent)
                calculate_new_elo(user, opponent)
                move_game_to_completed(abandoned_game)

        else:
            # TODO: Dereference from opponent (remake)
            opponent['Games'] = [game if game != abandoned_game['_id'] else 'none' for game in opponent['Games']]
            move_game_to_completed(abandoned_game)

            players.replace_one({"Username": user["Username"]}, user)
            players.replace_one({"Username": opponent["Username"]}, opponent)
            # TODO: in the future, we need to be aware of abandoned games in this way so that they don't mess with us showing the user a history of their games played.
            # Also, we need to remember that sometimes people abandon before the characters have been chosen, and deal with that appropriately.
            # What are all of the potential edge cases?

        games.find_one_and_update({"_id": abandon_game_id}, {'$push': {'Moves': abandon_str},
                                                             '$set': {'p1_abandon': player_num == 1,
                                                                      'p2_abandon': player_num == 2,
                                                                      'active_player': opponent['Username'],
                                                                      'p1c1': 'Knight' if 'p1c1' not in abandoned_game.keys() else
                                                                      abandoned_game['p1c1'],
                                                                      'p1c2': 'Knight' if 'p1c2' not in abandoned_game.keys() else
                                                                      abandoned_game['p1c2'],
                                                                      'p2c1': 'Knight' if 'p2c1' not in abandoned_game.keys() else
                                                                      abandoned_game['p2c1'],
                                                                      'p2c2': 'Knight' if 'p2c2' not in abandoned_game.keys() else
                                                                      abandoned_game['p2c2'],
                                                                      'p1_turn': player_num == 2,
                                                                      'most recent activity': [datetime.now(),
                                                                                               'p' + str(player_num),
                                                                                               'apply abandon penalty']}})
        return {'user': dumps(user), 'delta': delta}, 200

    except Exception as e:
        # Error; couldn't get the body of the request.
        print(e)
        return "Bad request, couldn't parse : " + str(e), 400


# takes a single game_id and returns the document
@app.route('/find_game', methods=["PUT"])
def find_game():
    try:
        body = ast.literal_eval(json.dumps(request.get_json()))
        game = games.find_one({"_id": ObjectId(body["$oid"])})
        return dumps(game), 200
    except:
        return "Bad request, couldn't parse", 400


@app.route('/turn_over', methods=["PUT"])
@lock(LOCK_TAKE_TURN)
def turn_over():
    try:
        print('enter')
        curr_game = request.get_json()
        curr_game["_id"] = ObjectId(curr_game["_id"]["$oid"])
        curr_game["p1"] = ObjectId(curr_game["p1"]["$oid"])
        game_object = games.find_one({"_id": curr_game["_id"]})
        print("got objects")

        # Grab the player ID who just moved, and update that part of the game document.
        last_player = curr_game["Moves"][-1][:2]

        print("Got last player")

        curr_game["p2"] = ObjectId(curr_game["p2"]["$oid"])

        print("managing eager beaver")
        # Manage Eager Beaver badge
        if (datetime.now() - game_object["most recent activity"][0]).total_seconds() < 60:
            print("Getting curr player")
            curr_player_doc = players.find_one({"_id": curr_game[last_player]})
            curr_player_doc['badge_progressions'][BADGE_EAGER_BEAVER] += 1
            print("replacig player")
            players.find_one_and_replace({"_id": curr_game[last_player]}, curr_player_doc)


        print("replacing most recent activity")
        curr_game["most recent activity"] = [datetime.now(), last_player]

        if 'usernames' not in curr_game.keys():
            curr_game['usernames'] = game_object['usernames']

        # Notify the active player.
        old_active_player = copy(curr_game["active_player"])
        curr_game["active_player"] = curr_game["usernames"][0] if curr_game["p1_turn"] else curr_game["usernames"][1]
        notify_move(curr_game["active_player"], old_active_player)


        games.find_one_and_update({"_id": curr_game["_id"]},
                                  {"$set": curr_game})


        return "True", 200
    except Exception as e:
        print(e)
        return "Bad request, couldn't parse. Error: " + str(e), 400



def build_notification_message(user, opp):
    taunts = [
        "Don't keep them waiting!",
        "They don't know what's coming...",
        "Time to get some vengance!",
        "Show them what you're made of!",
        "Ready to claim victory?",
        "Ready? Or are you too chicken to respond?",
        "",
        "Time to log in again!",
        "Go demolish your enemies!",
        "⚔️",
        "It's battle time!",
        "💪",
        "",
        "", 
        "", 
        "There's only one way this can end: victory.",
        "Is victory within your grasp?",
        "I can't believe they keep coming back for more!",
        opp + " can't have thought this through!",
        "Ten fake internet points says you've got this!",
        "Who do they think they are anyway? Challenging YOU, of all people!"
    ]
    intros = [
        "Hey!",
        "Psssttttt...",
        "Oh — check it out!",
        "Would you believe it?",
        "Storm's a-coming...",
        "Little nudge just to let you know:",
        "Us again!",
        "",
        "Hello, it's RPGLite;",
        "Ah, I thought so.",
        "Listen, I've run the numbers and I've discovered something:",
        "<RPGLite messenger pigeon unfurls a scroll from its leg...>",
        "I can't believe I'm saying this, but:",
        "", 
        "",
        "", 
        "<Official RPGLite fanfare begins...>",
        "The developers gave me a message to pass on.",
        "1 new message for " + user + ":",
        "Again. I know!",
        opp + " gave me a message to pass on.",
        "I've been learning to read smoke signals! The chimney over there says:"
    ]
    def build_middle_section(user, opp):
        options = [
            "You have a move to make in your game against " + opp + ".",
            opp + " is waiting for you to take your turn!",
            "Everybody's saying that " + user + " has to respond to " + opp + "'s last turn...",
            "Who has a new move to make? It's you, " + user + "!",
            user + " has a new turn to take against " + opp + ".",
            "There's a move you can make against " + opp + ".",
            opp + " has just stepped back into the ring...!",
            "Grab some popcorn and watch " + opp + " battling...wait, is that you, " + user + "?",
            "It's another one of the greats. Ali vs Foreman. Arsenal vs Chelsea. " + user + " vs " + opp + "...",
            "It's " + user + " 🆚 " + opp + "...and you're up!",
            "Three things in life are certain, and the best one is that you have a new move waiting against " + opp + "!",
            "I'm so excited to see what " + user + " does next against " + opp + "!"
        ]
        return random.choice(options)

    message = random.choice(intros) + " " + build_middle_section(user, opp) + " " + random.choice(taunts)
    print(message)
    return message

def notify_move(user, opp):
    send_notification(user, "Make a move!", build_notification_message(user, opp))

def send_notification(user, notification_header, notification_text):
    new_notification = onesignal_sdk.Notification(post_body={"contents": {"en": notification_text},
                                                             "include_external_user_ids": [user]})
    new_notification.post_body["headings"] = {"en": notification_header}

    onesignal_response = onesignal_client.send_notification(new_notification)
    print(onesignal_response.status_code)
    print(onesignal_response.json())

def calc_partial_delta(p1, p2, won=True):
    '''
    Calculates the little extra delta on the ranking of two players.
    :param p1: Float Delta. The player whose delta is being calculated
    :param p2: Float Delta. P1's opponent
    :param won: Bool. Did P1 win or lose?
    :return: Float delta
    '''

    # Logic for the deltas with bands:
    # 40 to go up. 10 to go down.
    # +- 1 for each band between the players.

    base = 40 if won else 10
    band_delta = abs(skill_level_band(p1) - skill_level_band(p2))
    band_delta = min(10 if won else 5, band_delta)  # Hard ceiling
    # if p1 > p2:
    #     band_delta *= -1
    delta = base + band_delta if either(won, p1 > p2) else base - band_delta
    if not won:
        delta *= -1

    return delta


    # Old calculations.

    # d = p1 - p2
    # if d < -250:
    #     d = -250
    # if d > 250:
    #     d = 250
    #
    # d = d // 50
    #
    # d *= -1 if won else 1
    #
    # return d

    # diff = abs(p1-p2)
    # return_d = 0
    # if diff > 250:
    #     return_d = 5
    # else:
    #     return_d = diff//50
    #
    # if won:
    #     return return_d
    # return return_d * (-1)

def skill_level_band(points):
    level_size = 100
    return points // level_size

def skill_level_floor(points):
    level_size = 100
    return points - (points % level_size)


def calc_delta(p1, p2, won=True):
    # NOTE: once you hit a level, you can never fall below it with this method.
    # I think that's what we agreed but can't remember.

    delta = calc_partial_delta(p1, p2, won)

    if won:
        return delta
    else:
        return max(delta, -abs(skill_level_floor(p1) - p1))

    # Old calculations.

    # delta = 30 if won else 20
    # delta += calc_partial_delta(p1, p2, won)
    # return delta * -1 if not won else delta


@app.route('/game_over', methods=["PUT"])
@lock(LOCK_TAKE_TURN)
def game_over():
    try:
        # Get some stuff from the DB
        body = ast.literal_eval(json.dumps(request.get_json()))
        game = games.find_one({"_id": ObjectId(body['game']["$oid"])})
        user = players.find_one({"_id": ObjectId(body['user']["$oid"])})
        opponent = players.find_one({"_id": ObjectId(game['p1'] if user['_id'] != game['p1'] else game['p2'])})

        player_string = "p1" if game["p1"] == user["_id"] else "p2"

        if "elo_scores_at_end" not in game:
            game["elo_scores_at_end"] = dict()
        if "skill_points_at_end" not in game:
            game["skill_points_at_end"] = dict()

        # Did the player win? val returned as string of bool
        if game["p1_abandon"] or game["p2_abandon"]:
            user_won_game = "Abandon"

            # Abandon logic. If the last move was more than a day ago, the person who most recently made a move wins.
            if (datetime.now() - game['most recent activity'][0]).days > 0:
                user_won_game = game['most recent activity'][1] == ('p1' if game['p1_abandon'] else 'p2')

        else:
            user_won_game = not (game[player_string + "c1_health"] <= 0 and game[player_string + "c2_health"] <= 0)

        if 'seen_by_one' not in game:
            game["end_time"] = datetime.now()
            elo_scores = calculate_new_elo(*(user, opponent) if user_won_game else (opponent, user))
            game["elo_scores_at_end"][user['Username']] = elo_scores[0 if user_won_game else 1]
            game["elo_scores_at_end"][opponent['Username']] = elo_scores[0 if not user_won_game else 1]

        # Deal with player doc
        user["Played"] = user["Played"] + 1

        # Default to 0 if the game is abandoned
        delta = 0

        if user_won_game != "Abandon":
            user.get('count_character_has_been_played', {l: 0 for l in CHARACTER_ORDERING})[
                game[player_string + "c1"][0]] += 1
            user.get('count_character_has_been_played', {l: 0 for l in CHARACTER_ORDERING})[
                game[player_string + "c2"][0]] += 1
            user['badge_progressions'][CHARACTER_ORDERING.index(game[player_string + "c2"][0]) * 2] += 1

            update_how_many_times_chars_played(user)
            update_badge_games_played(user)

            delta = calc_delta(user.get('current_season_skill', 0), opponent.get('current_season_skill', 0), user_won_game)

            user['skill_points'] = max((user['skill_points']//100)*100, user['skill_points'] + delta)
            user['current_season_skill'] = max((user['current_season_skill']//100)*100, user['current_season_skill'] + delta)
            game['skill_points_at_end'][user['Username']] = user['skill_points']

            if user_won_game:

                # opp abandon or player win increases 'won'
                user["Won"] = user["Won"] + 1

                update_skill_disparity_badge(user, opponent)
                update_win_streak_badge(user, opponent)
                update_vengeance_badge(user, opponent)

                # If either char at max health, update BADGE_WIN_X_WITH_CHAR_AT_FULL
                if MAX_HEALTHS[CHARACTER_ORDERING.index(game[player_string + "c1"][0])] == game[player_string + "c1_health"] \
                        or MAX_HEALTHS[CHARACTER_ORDERING.index(game[player_string + "c2"][0])] == game[player_string + "c2_health"]:
                    user['badge_progressions'][BADGE_WIN_X_WITH_CHAR_AT_FULL] += 1

                # If player wins with only 1 health remaining, update BADGE_WINN_X_WITH_1_HEALTH
                if game[player_string + "c1_health"] + game[player_string + "c2_health"] == 1:
                    user['badge_progressions'][BADGE_WIN_X_WITH_1_HEALTH] += 1

                # If game completed in under an hour, update BADGE_WIN_X_IN_UNDER_1H.
                if (game['start_time'] - game['end_time']).total_seconds() < 60 * 60:
                    increment_badge(user, BADGE_WIN_X_IN_UNDER_1H, post=False)

                user.get('count_character_has_won', {l: 0 for l in CHARACTER_ORDERING})[
                    game[player_string + "c1"][0]] += 1
                user['badge_progressions'][CHARACTER_ORDERING.index(game[player_string + "c1"][0]) * 2 + 1] += 1
                user.get('count_character_has_won', {l: 0 for l in CHARACTER_ORDERING})[
                    game[player_string + "c2"][0]] += 1
                user['badge_progressions'][CHARACTER_ORDERING.index(game[player_string + "c2"][0]) * 2 + 1] += 1

            else:
                # Record people we've lost against so we can take vengance for the appropriate badge
                user['lost_against'] = user.get('lost_against', [])
                user['lost_against'].append(opponent['Username'])

                update_lose_streak_badge(user, opponent)
        else:
            if len(game["most recent activity"]) > 2 and game["most recent activity"][2] == "apply abandon penalty":
                delta = calc_delta(user['current_season_skill'], opponent['current_season_skill'], won=True)
                user["skill_points"] += delta
                user["current_season_skill"] == delta

        # Dereference game
        for i in range(5):
            if user["Games"][i] == game["_id"]:
                user["Games"][i] = "none"

        update_skill_point_max_badge(user)
        user['badge_progressions'][BADGE_EXPLORER] = \
            1 if list(user['count_character_has_been_played'].values()).count(0) <= 1 else 0

        players.replace_one({"_id": ObjectId(body['user']["$oid"])}, user)
        players.replace_one({"_id": opponent['_id']}, opponent)

        # Deal with game doc
        if user_won_game and user_won_game != "Abandon":
            game["winner"] = int(player_string[1])

        if "seen_by_one" in game:
            # doc can be deleted: both players have seen it.
            games.delete_one({"_id": ObjectId(body['game']["$oid"])})
            completed_games.insert_one(game)

        else:
            # user is the first player to see the game over screen, so don't delete yet but do some bookkeeping
            game["seen_by_one"] = True
            games.replace_one({"_id": ObjectId(body['game']["$oid"])}, game)

        # Delta defaults to 0
        return {'user': dumps(user), 'skill_delta': delta, 'game_abandoned': user_won_game == 'Abandon'}

    except Exception as e:
        return "Bad request, couldn't parse. Error: " + str(e), 400


@app.route('/new_game_vs_waitinglist', methods=["PUT"])
def new_game_vs_waiting():
    # Wallacian magic to get inner whatever.
    try:
        try:
            # Build game doc and insert
            body = ast.literal_eval(json.dumps(request.get_json()))
            search_id = body["_id"]["$oid"]
            waiting_id = players.find_one({"waiting_list": True})["waiting"]
            waiting = players.find_one({"_id": waiting_id})
            searcher = players.find_one({"_id": ObjectId(search_id)})
            new_game = {
                "p1": waiting_id,
                "p2": ObjectId(search_id),
                "p1_selected": False,
                "p2_selected": False,
                "p1_turn": False,
                "Moves": [],
                "active_player": 'none',
                "most recent activity": [datetime.now(), searcher['Username']],
                "balance_code": RPGLITE_CURR_BALANCE
            }
            games.insert_one(new_game)
            new_game_id = games.find_one(new_game)["_id"]

            # update player badges
            waiting['badge_progressions'][BADGE_MATCHMAKE_FROM_WAITING] += 1
            searcher['badge_progressions'][BADGE_MATCHMAKE_FROM_WAITING] += 1

            # UPDATE WAITING PLAYER'S GAMES []
            waiting_slot = players.find_one({"waiting_list": True})["slot"]
            waiting["Games"][waiting_slot] = new_game_id
            players.replace_one({"_id": waiting_id}, waiting)

            # UPDATE SEARCHING PLAYER'S GAMES []
            searcher["Games"][body["slot"]] = new_game_id
            players.replace_one({"_id": ObjectId(search_id)}, searcher)

            # UPDATE WAITING LIST
            clear_waiting_list = {
                "waiting_list": True,
                "waiting": None,
                "slot": None,
            }
            players.replace_one({"waiting_list": True}, clear_waiting_list)

            send_new_match_notification(waiting['Username'], searcher['Username'])

            # Return success and the document
            return dumps(searcher), 200

        except Exception as e:
            # Error; couldn't get the body of the request.
            print(e)
            return "Bad request, couldn't parse: " + str(e), 400
    except:
        # Something went wrong, but this is too generic to work out what might have happened.
        return "Server error from autogenerated endpoint", 500


@app.route('/register', methods=["PUT"])
@lock(LOCK_REGISTER)
def register(user=None):
    try:
        try:
            if user is None:
                # Get the JSON doc from view
                body = ast.literal_eval(json.dumps(request.get_json()))

                if len(list(players.find({"Username": body["cred_username"]}))) > 0:
                    return "Could not register; username already exists", 400

                # Create the new user doc
                user = {
                    'Username': body["cred_username"],
                    'Password': body["cred_hashed_pw"],
                    "Played": 0,
                    "Won": 0,
                    'tag_bg': random.choice(['blue', 'purple', 'orange', 'green']),
                    "Games": ["none", "none", "none", "none", "none"],
                    "count_character_has_won": {l: 0 for l in CHARACTER_ORDERING},
                    "count_character_has_been_played": {l: 0 for l in CHARACTER_ORDERING},
                    'accepting_games': True,
                    'skill_points': 0,
                    'current_season_skill': 0,
                    'last_logged_in': datetime.now(),
                    'badge_progressions': [0] * BADGE_INFO_SPACES
                }
            # Insert the document
            players.insert_one(user)

            # Make and store the new user a magic key
            magic_key = generate_magic_key()
            special_data.find_one_and_update({"password_reset_keys": {"$exists": True}}, {"$set": {user['Username']: magic_key}})

            # Update the document of new users
            process_new_user_list(newusername=user["Username"])
            # Return success and the document
            return {"user": dumps(user), "magic_key": magic_key}, 200

        except:
            # Error; couldn't get the body of the request.
            return "Bad request, couldn't parse", 400
    except:
        # Something went wrong, but this is too generic to work out what might have happened.
        return "Server error from autogenerated endpoint", 500


@app.route('/find_opponent_username', methods=["PUT"])
def find_opponent_username():
    try:
        opponent_id = ast.literal_eval(json.dumps(request.get_json()))
        opponent = players.find_one({"_id": ObjectId(opponent_id)})
        opponent_username = opponent["Username"]
        games_user_played = completed_games.find({'$or': [{'p1': opponent['_id']},
                                                          {'p2': opponent['_id']}]})
        # print(games_user_played)
        return {"user": opponent_username,
                "skill_points": opponent['skill_points'],
                "total_completed_games": len(list(games_user_played)) if games_user_played is not None else 0,
                'background': opponent['tag_bg']}, 200
    except Exception as e:
        return "Bad request, couldn't parse: " + str(e), 400

@app.route('/update_bg/<username>/<new_background>', methods=['GET'])
def update_background(username, new_background):
    try:
        user_doc = players.find_one({'Username': username})
        if user_doc is None:
            return 'user not found', 400
        
        user_doc['tag_bg'] = new_background
        players.replace_one({"Username": username}, user_doc)
        return 'ok', 200
    except Exception as e:
        return 'something went wrong! ' + str(e), 500


@app.route('/download_consent/<username>', defaults={'kind': 'text'})
@app.route('/download_consent/<username>/', defaults={'kind': 'text'})
@app.route('/download_consent/<username>/<kind>')
def download_consent_form(username, kind='text'):
    try:
        print(username, kind)
        return username+ kind, 200
    except Exception as e:
        return "Error: "+str(e), 500

@app.route('/new_user_list')
def get_new_user_list():
    v = 0
    try:
        userlist = players.find_one({'new_users': True})
        # check if they're outdated
        userlist, hell = process_new_user_list(userlist)
        v += 1

        print(2 if userlist is not None else 453)

        if hell is not None:
            raise hell

        v += 1
        return {"users": list(map(lambda u: u[0], userlist['users']))}, 200

    except Exception as e:
        return repr(e), 400


def pad(xs, topad, length=5):
    while len(xs) < length:
        xs.append(topad)

@app.route('/reset_slot/<user>/<slot>')
def reset_slot(user, slot):
    user_doc = players.find_one({'Username': user})
    if user_doc is None:
        return "couldn't find user", 410
    
    slot = int(slot)
    user_doc['Games'][slot] = 'none'
    players.replace_one({'_id': user_doc['_id']}, user_doc)
    return dumps(user_doc), 200

@app.route("/accept_challenges/<challengee>")
def challenge(challengee):
    ok, err = post_challenge(challengee)

    if str(err) == 'User already challenged':
        return "Can't challenge more than once! Give 'em a chance!", 400
    elif str(err) == 'No free slots to challenge':
        return 'No free slots to challenge', 400
    elif err is not None:
        return "failure!" + str(err), 500
    else:
        return "ok", 200


@app.route('/reject_challenges/<challengee>')
def reject_challenges(challengee):
    try:
        victim_list = players.find_one({'challengee_list': True})

        if challengee not in map(lambda u: u[0], victim_list["challengees"]):
            return "Can't reject challenges if you're not accepting any yet!", 400

        new_list = clean_challeges(victim_list['challengees'])

        new_list = list(filter(lambda u: u[0] != challengee, new_list))

        # Pad the new list
        pad(new_list, ['none', None])

        victim_list['challengees'] = new_list
        players.replace_one({'challengee_list': True}, victim_list)
        return {"challengees": new_list,
                "skill_points": list(map(lambda u: u.get('skill_points', 100) if u is not None else 100,
                                         players_from_usernames(new_list)))
                }, 200

    except Exception as e:
        return "failure! " + str(e), 500


@app.route('/get_challengees')
def get_challengees():
    try:
        challengees = clean_challeges(post=True)
        c_usernames = list(map(lambda u: u[0], challengees))
        c_users = players_from_usernames(c_usernames)
        return {"challengees": c_usernames,
                'skill_points': list(
                    map(lambda u: u['skill_points'] if u is not None and 'skill_points' in u.keys() else 100, c_users))
                }, 200
    except Exception as e:
        print(e)
        return "Failure! " + str(e), 500


def process_new_user_list(userlist=None, update=True, newusername=None):
    try:

        # Get userlist if we don't have any
        if userlist is None:
            userlist = players.find_one({'new_users': True})

        # Add new user if you want to
        if newusername is not None:
            userlist['users'] = [[newusername, datetime.now()]] + userlist['users'][:-1]

        filtered_users = list(filter(lambda u: u[0] == 'none' or (datetime.now() - u[1]).days < 3, userlist['users']))

        # Pad the new list
        pad(filtered_users, ['none', None])

        userlist['users'] = filtered_users
        if update:
            players.replace_one({"new_users": True}, userlist)

        return userlist, None
    except Exception as e:
        return None, e


def players_from_usernames(usernames=None):
    '''
    Takes a list of usernames and returns the mongo documents for the user with that username.
    :param usernames: A list of usernames
    :return: A list of mongo documents of users with the corresponding names
    '''

    def get_user(user):
        return players.find_one({'Username': user})

    return list(map(get_user, usernames))


def check_user_has_free_slots(user):
    try:
        if isinstance(user, str):
            user = players.find_one({'username'})

        return 'none' in user['Games']

    except Exception as e:
        raise e


def clean_challeges(challengee_list=None, post=False):
    if challengee_list is None:
        challengee_list = players.find_one({'challengee_list': True})['challengees']

    new_list = []
    for challengee in challengee_list:
        if challengee[0] != 'none':

            player = players.find_one({'Username': challengee[0]})
            if (datetime.now() - challengee[1]).days < 3 and player['accepting_games'] and check_user_has_free_slots(
                    player):
                new_list.append(challengee)

    pad(new_list, ['none', None])

    if post:
        doc = players.find_one({'challengee_list': True})
        doc['challengees'] = new_list
        players.replace_one({'challengee_list': True}, doc)

    return new_list


def post_challenge(victim):
    try:
        victim_list = players.find_one({'challengee_list': True})

        player_dict = players.find_one({"Username": victim})

        if victim in map(lambda u: u[0], victim_list['challengees']):
            return None, Exception("User already challenged")

        if not check_user_has_free_slots(player_dict):
            return None, Exception("No free slots to challenge")

        new_list = [[victim, datetime.now()]] + victim_list['challengees'][:-1]

        # Pad the new list
        pad(new_list, ['none', None])

        victim_list['challengees'] = new_list
        increment_badge(player_dict, BADGE_CHALLENGES_POSTED, post=True)
        players.replace_one({'challengee_list': True}, victim_list)
        return victim_list, None

    except Exception as e:
        return None, e


def increment_badge(user, badge_index, post=False):
    if isinstance(user, str):
        user = players.find_one({'Username': user})

    user['badge_progressions'][badge_index] += 1

    if post:
        players.replace_one({"Username": user['Username']}, user)


@app.route('/stop_accepting_games/<username>')
def stop_accepting_games(username):
    try:
        player = players.find_one({"Username": username})
        player['accepting_games'] = False
        reject_challenges(username)
        players.replace_one({'Username': username}, player)
        return 'ok', 200
    except Exception as e:
        return "Terrible things have happened: " + str(e), 500


@app.route('/start_accepting_games/<username>')
def start_accepting_games(username):
    try:
        player = players.find_one({"Username": username})
        player['accepting_games'] = True
        players.replace_one({'Username': username}, player)
        return 'ok', 200
    except Exception as e:
        return "Terrible things have happened: " + str(e), 500


@app.route('/toggle_accepting_games/<username>')
def toggle_accepting_games(username):
    try:
        player = players.find_one({"Username": username})
        player['accepting_games'] = not (player.get('accepting_games', False))
        if not player['accepting_games']:
            reject_challenges(username)
        players.replace_one({'Username': username}, player)
        return 'ok', 200
    except Exception as e:
        return "Terrible things have happened: " + str(e), 500


@app.route('/buckets')
def buckets(num_buckets=10, skills=None):
    try:
        if skills is None:
            skills = [u["skill_points"] for u in players.find({"skill_points": {"$exists": True}},
                                                              projection={"_id": False,
                                                                          "skill_points": True},
                                                              sort=[("skill_points", -1)])]

        max_skill = max(skills)

        buckets = [0] * num_buckets
        for s in skills:
            if s == max_skill:
                buckets[9] += 1
            else:
                buckets[int(str(s / max_skill)[2])] += 1

        # I think we can just replace this with:
        # for s in skills:
        #     if s != max_skill:
        #         buckets[int((s/max_skill) * num_buckets)] += 1
        #     else:
        #         buckets[-1] += 1
        # which feels a little more robust...

        return {'bucket_sizes': buckets,
                'maximum': max_skill}, 200

    except Exception as e:
        return "Something terrible happened! " + str(e), 500


@app.route('/percentile/<username>')
def percentile(username, allskills=None):
    try:
        if allskills is None:
            allskills = {u["Username"]: u["skill_points"] for u in players.find({"skill_points": {"$exists": True}},
                                                                                projection={"_id": False,
                                                                                            "Username": True,
                                                                                            "skill_points": True})}

        ourskill = allskills[username]
        return {'percentile': int(
            100 * len(list(filter(lambda s: s <= ourskill, allskills.values()))) / len(allskills))}, 200

    except Exception as e:
        return "Something terrible happened! " + str(e), 500


@app.route('/leaderboard/<username>')
def leaderboard(username, allskills=None):
    try:
        # log_datapoint('leaderboard', username)
        if allskills is None:
            allskills = players.find({"skill_points": {"$gt": 1}},
                                     projection={"_id": False, "Username": True, "skill_points": True},
                                     sort=[("skill_points", -1)])

        ranked_skills = [
            [allskills[0]["Username"], allskills[0]["skill_points"], 1]]  # [[username, skill points, ranking]]
        for user in allskills[1:]:
            rank = ranked_skills[-1][2]
            if user["skill_points"] != ranked_skills[-1][1]:
                rank = len(ranked_skills) + 1

            ranked_skills.append([user["Username"], user["skill_points"], rank])

        return {'ranks': ranked_skills,
                'total': len(list(players.find({"Username": {"$exists": True}})))}, 200

    except Exception as e:
        return "Something terrible happened! " + str(e), 500

@app.route('/seasonal_leaderboard/<username>')
def seasonal_leaderboard(username, allskills=None):
    try:
        # log_datapoint('leaderboard', username)
        if allskills is None:
            allskills = players.find({"current_season_skill": {"$gt": 1}},
                                     projection={"_id": False, "Username": True, "current_season_skill": True},
                                     sort=[("current_season_skill", -1)])

        ranked_skills = [
            [allskills[0]["Username"], allskills[0]["current_season_skill"], 1]]  # [[username, skill points, ranking]]
        for user in allskills[1:]:
            rank = ranked_skills[-1][2]
            if user["current_season_skill"] != ranked_skills[-1][1]:
                rank = len(ranked_skills) + 1

            ranked_skills.append([user["Username"], user["current_season_skill"], rank])

        return {'ranks': ranked_skills,
                'total': len(list(players.find({"Username": {"$exists": True}})))}, 200

    except Exception as e:
        print(e)
        return "Something terrible happened! " + str(e), 500





@app.route('/log_datapoint', methods=['PUT'])
def log_datapoint(kind=None, username=None, **kwargs):
    try:
        print("getting data")
        print(request.get_json() == None, request.get_json() == "")
        data = ast.literal_eval(json.dumps(request.get_json()))
        print("deserialised")

        data['time'] = datetime.now()
        data['balance_code'] = RPGLITE_CURR_BALANCE
        if kind is not None:
            data['kind'] = kind
        if username is not None:
            data['user'] = username
        if kwargs != {}:
            data.update(kwargs)

        if None in [data.get('kind', None), data.get('user', None)]:
            return "Bad log! User was " + str(username) + " and kind was " + str(kind), 400

        print("updatig")
        data.update(kwargs)

        print("posting")
        page_hits.insert_one(data)

        return {k: v for k, v in data.items() if k != '_id'}, 200
    except Exception as e:
        print('hit an issue: ' + str(e))
        return 'hit an issue: ' + str(e), 500

@app.route("/reset_password", methods=["PUT"])
def reset_password():
    '''
    Resets the user password, provided a valid pairing of magickey to user.
    in the data passed by json, we have 3 keys:
    :param user: The string username of the person who's password we're resetting.
    :param magickey: The magic key for that user.
    :param newpass: The user's desired new password, already SHA-1 hashed.
    :return: A new magickey if successful, or an error if not.
    '''

    data = dict()
    try:
        data = ast.literal_eval(json.dumps(request.get_json()))
    except Exception as e:
        print(e)
        return "Bad request, couldn't parse: " + str(e), 500

    user = data["user"]
    magickey = data["magickey"]
    newpass = data["newpass"]

    reset_keys = special_data.find_one({'password_reset_keys': {'$exists': True}})

    userpass = players.find_one({"Username": user})["Password"]

    stored_key = reset_keys.get(user, None)

    if stored_key == magickey or stored_key is None or magickey == userpass:
        # Set a new password.
        players.find_one_and_update({'Username': user}, {'$set': {'Password': newpass}})

        # Generate a new magickey, and set it in the database.
        new_key = generate_magic_key()
        special_data.find_one_and_update({'password_reset_keys': {'$exists': True}}, {"$set": {user: new_key}})

        # Return that key and a 200.
        return {'new_key': new_key}, 200

    else:
        return "Invalid magic key for user " + user, 400


def generate_magic_key():
    key = ""
    for _ in range(16):
        key += random.choice(['a', 'b', 'c', 'd', 'e', 'f', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'])
    return key


@app.route('/percentile_with_buckets/<username>')
def perc_with_buckets(username):
    try:
        # log_datapoint('profile', username)
        allskills = players.find({"skill_points": {"$gt": 1}},
                                 projection={"_id": False, "Username": True, "skill_points": True},
                                 sort=[("skill_points", -1)])

        bucket_sizes_and_max, bucket_code = buckets(skills=[u["skill_points"] for u in allskills])
        if bucket_code is not 200: return bucket_sizes_and_max, bucket_code

        allskills.rewind()
        perc, perc_code = percentile(username, allskills={u["Username"]: u["skill_points"] for u in allskills})
        if perc_code is not 200: return perc, perc_code

        return {'buckets': bucket_sizes_and_max,
                'percentile': perc}, 200


    except Exception as e:
        return "Something terrible happened! " + str(e), 500

@app.route('/seasonal_percentile_with_buckets/<username>')
def seasonal_perc_with_buckets(username):
    try:
        # log_datapoint('profile', username)
        allskills = players.find({"current_season_skill": {"$gt": 1}},
                                 projection={"_id": False, "Username": True, "current_season_skill": True},
                                 sort=[("current_season_skill", -1)])

        bucket_sizes_and_max, bucket_code = buckets(skills=[u["current_season_skill"] for u in allskills])
        if bucket_code is not 200: return bucket_sizes_and_max, bucket_code

        allskills.rewind()
        perc, perc_code = percentile(username, allskills={u["Username"]: u["current_season_skill"] for u in allskills})
        if perc_code is not 200: return perc, perc_code

        return {'buckets': bucket_sizes_and_max,
                'percentile': perc}, 200


    except Exception as e:
        print(e)
        return "Something terrible happened! " + str(e), 500



@app.route("/profile/<username>")
def profile(username):
    try:
        # log_datapoint('true_profile', username)
        allskills = players.find({"skill_points": {"$exists": True}},
                                 projection={"_id": False, "Username": True, "skill_points": True},
                                 sort=[("skill_points", -1)])

        bucket_sizes_and_max, bucket_code = buckets(skills=[u["skill_points"] for u in allskills])
        if bucket_code is not 200: return bucket_sizes_and_max, bucket_code

        allskills.rewind()
        perc, perc_code = percentile(username, allskills={u["Username"]: u["skill_points"] for u in allskills})
        if perc_code is not 200: return perc, perc_code

        allskills.rewind()
        leader, leaderboard_code = leaderboard(allskills)
        if leaderboard_code is not 200: return leader, leaderboard_code

        return {'buckets': bucket_sizes_and_max,
                'percentile': perc,
                'leaderboard': leaderboard}, 200


    except Exception as e:
        return "Something terrible happened! " + str(e), 500


def update_skill_point_max_badge(user):
    user['badge_progressions'][BADGE_SKILL_POINT_MAX] = max(user['badge_progressions'][BADGE_SKILL_POINT_MAX],
                                                            user['skill_points'])

    user['badge_progressions'][BADGE_SEASONAL_SKILL_POINT_MAX] = max(user['badge_progressions'][BADGE_SEASONAL_SKILL_POINT_MAX],
                                                            user['current_season_skill'])

    user['badge_progressions'][BADGE_PERCENTILE_REACHED] = max(user['badge_progressions'][BADGE_PERCENTILE_REACHED],
                                                               percentile(user['Username'])[0]['percentile'])


def update_vengeance_badge(user, opponent):
    if opponent['Username'] in user.get('lost_against', []):
        user['badge_progressions'][BADGE_VENGEANCE] += 1
        user['lost_against'].remove(opponent['Username'])


def update_skill_disparity_badge(user, opponent):
    user_skill = user['skill_points']
    opponent_skill = opponent['skill_points']

    badge = BADGE_SKILL_MORE if user_skill < opponent_skill else BADGE_SKILL_LESS

    user['badge_progressions'][badge] = max(user['badge_progressions'][badge], abs(user_skill - opponent_skill))

def update_skill_disparity_badge(user, opponent):
    user_skill = user['current_season_skill']
    opponent_skill = opponent['current_season_skill']

    badge = BADGE_SEASONAL_SKILL_MORE if user_skill < opponent_skill else BADGE_SEASONAL_SKILL_LESS

    user['badge_progressions'][badge] = max(user['badge_progressions'][badge], abs(user_skill - opponent_skill))


def update_night_owl_badge(user):
    if datetime.now().hour < 4:
        user['badge_progressions'][BADGE_NIGHT_OWL] += 1


def update_how_many_times_chars_played(user):
    user['badge_progressions'][BADGE_NUM_TIMES_ALL_CHARS_PLAYED] = min(user['count_character_has_been_played'].values())
    user['badge_progressions'][BADGE_PLAY_WITH_SINGLE_CHAR] = max(user['count_character_has_been_played'].values())


def update_win_streak_badge(user, opponent):
    user['badge_progressions'][BADGE_LONGEST_WIN_STREAK + 1] += 1

    user['badge_progressions'][BADGE_LONGEST_WIN_STREAK] = max(user['badge_progressions'][BADGE_LONGEST_WIN_STREAK + 1],
                                                               user['badge_progressions'][BADGE_LONGEST_WIN_STREAK])
    opponent['badge_progressions'][BADGE_LONGEST_WIN_STREAK + 1] = 0


def update_badge_games_played(user):
    user['badge_progressions'][BADGE_PLAY_X_GAMES] += 1


def set_default_value_for_users(field, defaultval, force=False):
    ps = players.find({"Username": {"$exists": True}})
    for player in ps:
        val = defaultval() if callable(defaultval) else defaultval
        player[field] = player.get(field, val) if not force else val
        players.replace_one({"Username": player["Username"]}, player)


def update_lose_streak_badge(user, opponent):
    user['badge_progressions'][BADGE_PERSISTENT + 1] += 1
    user['badge_progressions'][BADGE_PERSISTENT] = max(user['badge_progressions'][BADGE_PERSISTENT],
                                                       user['badge_progressions'][BADGE_PERSISTENT + 1])

    opponent['badge_progressions'][BADGE_PERSISTENT + 1] = 0


def update_badges_chosen_from_lists(player, opp):  # types are Player doc, string respectively
    challengees = get_challengees()[0]['challengees']
    users = get_new_user_list()[0]['users']
    active_players = get_active_user_list(player['Username'])[0]['active_users']

    if opp in challengees:
        player['badge_progressions'][BADGE_ACCEPT_X_CHALLENGES] += 1

    if opp in users:
        player['badge_progressions'][BADGE_PLAY_X_NEW] += 1

    if opp in active_players:
        player['badge_progressions'][BADGE_ACTIVE_USERS] += 1

    return player


@app.route("/backup")
def back_up():
    print('running_backups')
    for collection, backup_location in filter(lambda x: x[0] in COLLECTIONS_TO_BACKUP, BACKUP_LOCATIONS):
        print('backing up ' + str(collection))
        for item in collection.find({}):
            item["backed_up_on"] = datetime.now()
            del item['_id']
            backup_location.insert_one(item)


# @app.route("/dereferences")
# @app.route("/dereferences/<format>")
def fix_dereferences(format='json'):

    def fix_broken_game(game, p1, p2):
        p1['Games'] = [g if g != game['_id'] else 'none' for g in p1['Games']]
        p2['Games'] = [g if g != game['_id'] else 'none' for g in p2['Games']]
        players.replace_one({'_id': p1['_id']}, p1)
        players.replace_one({'_id': p2['_id']}, p2)
        dereferenced_games.insert_one(game)
        games.delete_one(game)

    def has_not_hit_abandon_endpoint(game):
        # print(game['usernames'], game['p1_abandon'], game['p2_abandon'], game['most recent activity'])
        try:
            return (not game['p1_abandon'] and not game['p2_abandon']) \
                and 'apply abandon penalty' not in game['most recent activity']
        except:
            print('hit the except at ' + str(game))
            return False
        return False


    out = dict()
    out['possible dereferences'] = list()

    print("finding dereferences")
    for game in games.find({}):
        p1 = players.find_one({'_id': game['p1']})
        p2 = players.find_one({'_id': game['p2']})
        # print(game.get('usernames', list()), game.get('p1_abandon', False), game.get('p2_abandon', False), game['most recent activity'], p1['Games'], p2['Games'])
        try:
            
            if ( (game['_id'] in p1['Games'] and game['_id'] not in p2['Games']) or (game['_id'] in p1['Games'] and game['_id'] not in p2['Games']) ) \
                and has_not_hit_abandon_endpoint(game):
                print('dereference at ' + str(game['usernames']))
                if format == 'json':
                    out['possible dereferences'].append(game)
                elif format == 'text' or format == 'txt':
                    out['possible dereferences'].append('game with ID ' + str(game['_id']) + ', with players ' + str(game['usernames']))
                
        except Exception as e:
            print(e)


    if format == 'text' or format == 'txt':
        return '<br>'.join(out['possible dereferences']), 200
    return dumps(out), 200


@app.route("/dereferences")
@app.route("/dereferences/<format>")
def new_fix_dereferences(format="json"):


    bad_games = []
    checked = []
    for player in players.find({'Username': {'$exists': True}}):
        for game_id in player['Games']:
            if game_id != 'none' and game_id != 'waiting' and game_id not in checked:
                # print('checking ' + str(game_id))
                checked.append(game_id)
                game = games.find_one({'_id': game_id})
                if game is None:
                    try:
                        while True: exec(input('  :: '))
                    except:
                        pass

                # Check in opp's game list
                try:
                    opp_id = game['p1'] if game['p2'] == player['_id'] else game['p2']
                    opp = players.find_one({'_id': opp_id})
                    opp_has_game = game_id in opp['Games']
                except Exception as e:
                    print(e)
                    raise e

                # Check seen_by_one
                seen_by_one = 'seen_by_one' in game.keys()

                # Check abandon endpoint
                abandoned = game.get('p1_abandon', False) or game.get('p2_abandon', False) or 'apply abandon penalty' in game['most recent activity']

                # Overall
                is_valid_game = opp_has_game or seen_by_one or abandoned

                if not is_valid_game: 
                    print(game_id, player['Username'], opp['Username'], {'seen?': seen_by_one, 'abandoned?': abandoned, 'missing?': opp_has_game})
                    bad_games.append(game)

    return dumps({'bad_games': bad_games}), 200
    


@app.route("/ensure_backup/<location>")
def ensure_backup_happens(location):
    BACKUP_LOCATIONS.append(location) if location not in BACKUP_LOCATIONS else None


@app.route("/disable_backup/<location>")
def remove_backup_flag(location):
    BACKUP_LOCATIONS.remove(location) if location in BACKUP_LOCATIONS else None


@app.route("/version")
@app.route("/version/<username>")
def report_version(username=None):
    return {'version_string': MIDDLEWARE_VERSION,
            'change_log': MIDDLEWARE_CHANGESET}, 200


def add_badge_for_all_users():
    for player in players.find({"Username": {"$exists": True}}):
        player['badge_progressions'].append(0)
        players.replace_one({"Username": player['Username']}, player)


@app.route('/dev_secret_code/<username>')
def dev_secret_code(username=None):
    return {
        'season 2 completed games': len(list(completed_games.find({'balance_code': '1.2', 'winner': {"$exists": True}}))),
        'active season 2 users': len(list(players.find({'last_logged_in': {'$gt': datetime(2020, 5, 1, 15, 19)}})))
    }, 200


@app.route('/history/<username>')
def report_history(username):
    try:
        user_doc = players.find_one({"Username": username})

        all_games = completed_games.find({'$or': [{'p1': user_doc['_id']},
                                        {'p2': user_doc['_id']}]})

        sorted_games = sorted(filter(lambda g: 'end_time' in g, all_games), key=lambda g: g['end_time'])

        return {'games': list(map(dumps, sorted_games))}, 200
    except Exception as e:
        return "something went wrong!   " + str(e), 500


@app.route('/MOTD/<username>')
def motd(username):
    try:
        posted_messages = special_data.find_one({"messages": {"$exists": True}})
        for message in posted_messages['messages']:
            if username not in message[1]:
                message[1].append(username)
                special_data.find_one_and_replace({"messages": {"$exists": True}}, posted_messages)
                return message[0], 200
        return random.choice(["Thanks for playing RPGLite, " + username + "!",
                               "Excited to see you log in again!",
                               "Welcome back!",
                               "Surely you'll win this time?!",
                               "Knew you'd be back for more...",
                               "Thanks for contributing to our research!",
                               "Remember: you have medals in your profile, and a position in our global leaderboard!",
                               "Remember: characters are unlocked by playing at least once with every character who came before them.",
                               'Remember: if you want to play against new people, why not match against them from the "Active Users" list?',
                               "Remember: confident players will submit challenges in the find opponents tab. If you're better than them, why not place your own challenge?",
                               "Remember: if you're keen to rematch against somebody you've played before, you'll find them in your game history!",
                               "Skill points go up by ~40 points every time you win, and down by ~10 if you lose...depending on the difference between your skill and an opponent's!",
                               "Worried about your skill points dropping? Don't worry — they'll never dip below a multiple of 100 once you reach it. (You can think of that as your \"level\"!)",
                               "What's your position in the leaderboard? (It didn't drop, did it?)",
                               "Today's most brilliant player is you. Yes, you, " + username + ". 10/10. Keep it up! ❤️",
                               "Good to see you're having fun!",
                               "Oh look! It's our FAVOURITE player!",
                               "I didn't know we had such good looking users!"]), 200
    except Exception as e:
        print(e)
        return "There might be a message of the day for you; sorry, we couldn't get it.", 500


def move_game_to_completed(game_doc):
    games.remove({'_id': game_doc['_id']}, True)
    completed_games.insert_one(game_doc)


@app.route("/get_played_won/<username>")
def get_played_won(username):
    user = players.find_one({"Username": username})
    if user is None:
        print("Couldn't find provided user for get_played_won endpoint")
        return "Could not find user", 400

    played_won = []
    for char in CHARACTER_ORDERING:
        played_won.append(user["count_character_has_been_played"][char])
        played_won.append(user["count_character_has_won"][char])

    comma_separated_pw = ",".join(map(str, played_won))
    print(comma_separated_pw)

    return comma_separated_pw, 200

# def calculate_new_elo(winner, loser, post=True):
#     '''
#     Mostly inspired by https://github.com/rshk/elo/blob/master/elo.py
#     :param winner: The winner of a given game. Username or user doc from mongo.
#     :param loser: The loser of a given game. Username or user doc from mongo.
#     :param post: Whether to post new ELO scores to the database. Defaults to yes please that would be very nice.
#     :return: (integer new winner ELO, integer new loser ELO) as a Tuple.
#     '''
#     if isinstance(winner, str):
#         winner = players.find_one({"Username": winner})
#     if isinstance(loser, str):
#         loser = players.find_one({"Username": loser})
# 
#     winner_elo = winner.get('elo', ELO_DEFAULT)
#     loser_elo = loser.get('elo', ELO_DEFAULT)
# 
#     winner_diff = winner_elo - loser_elo
# 
#     def expected(diff):
#         return 1 / (1 + 10 ** (diff / 400))  # Hate this! Why the magic numbers?
# 
#     winner_expected, loser_expected = expected(winner_diff), expected(-winner_diff)
# 
#     winner_elo += ELO_K * (1-winner_expected)
#     loser_elo += ELO_K * (0-loser_expected)
#     winner['elo'] = winner_elo
#     loser['elo'] = loser_elo
# 
#     if post:
#         players.find_one_and_update({"Username": winner['Username']}, {"$set": {"elo": winner["elo"]}})
#         players.find_one_and_update({"Username": loser['Username']}, {"$set": {"elo": loser["elo"]}})
# 
#     return winner_elo, loser_elo


# def calculate_new_elo(winner, loser, post=True):
#     '''
#     Mostly inspired by https://github.com/rshk/elo/blob/master/elo.py
#     :param winner: The winner of a given game. Username or user doc from mongo.
#     :param loser: The loser of a given game. Username or user doc from mongo.
#     :param post: Whether to post new ELO scores to the database. Defaults to yes please that would be very nice.
#     :return: (integer new winner ELO, integer new loser ELO) as a Tuple.
#     '''
#     if isinstance(winner, str):
#         winner = players.find_one({"Username": winner})
#     if isinstance(loser, str):
#         loser = players.find_one({"Username": loser})

#     winner_elo = winner.get('elo', ELO_DEFAULT)
#     loser_elo = loser.get('elo', ELO_DEFAULT)

#     winner_diff = winner_elo - loser_elo

#     def expected(diff):
#         return 1.0 * 1.0 / (1 + 1.0 * pow(10, 1.0 * diff / 400))
#                                                                         # return 1 / (1 + 10 ** (diff / 400))  # Hate this! Why the magic numbers?

#     winner_expected, loser_expected = expected(winner_diff), expected(-winner_diff)

#     winner_elo += ELO_K * (1-winner_expected)
#     loser_elo += ELO_K * (0-loser_expected)
#     winner['elo'] = winner_elo
#     loser['elo'] = loser_elo

#     if post:
#         players.find_one_and_update({"Username": winner['Username']}, {"$set": {"elo": winner["elo"]}})
#         players.find_one_and_update({"Username": loser['Username']}, {"$set": {"elo": loser["elo"]}})

#     return winner_elo, loser_elo



#====William's ELO implementation======

# Function to calculate the Probability
def Probability(rating1, rating2):

    return 1.0 * 1.0 / (1 + 1.0 * math.pow(10, 1.0 * (rating1 - rating2) / 400))

# Function to calculate Elo rating
# K is a constant.
# d determines whether
# Player A wins or Player B.
# d: did p1 win?
# def EloRating(Ra, Rb, K, d):
def calculate_new_elo(winner, loser, post=True):

    # Adapt variables from signature to William's format
    Pa = winner["elo"]
    Pb = loser["elo"]
    d == 1              # We set winner as Pa because we know they won
    K = ELO_K

    # To calculate the Winning
    # Probability of Player B
    Pb = Probability(Ra, Rb)

    # To calculate the Winning
    # Probability of Player A
    Pa = Probability(Rb, Ra)

    # Case -1 When Player A wins
    # Updating the Elo Ratings
    if (d == 1):
        Ra = Ra + K * (1 - Pa)
        Rb = Rb + K * (0 - Pb)

    # Case -2 When Player B wins
    # Updating the Elo Ratings
    else:
        Ra = Ra + K * (0 - Pa)
        Rb = Rb + K * (1 - Pb)

    # set in player docs, and update db if necessary
    winner["elo"] = Ra
    loser["elo"] = Rb
    if post:
        players.find_one_and_update({"Username": winner['Username']}, {"$set": {"elo": winner["elo"]}})
        players.find_one_and_update({"Username": loser['Username']}, {"$set": {"elo": loser["elo"]}})

    return Ra, Rb


#====William's ELO implementation======


async def run_backups():
    while True:
        await asyncio.sleep(BACKUP_FREQUENCY_SECS)
        back_up()


@app.route("/test/<duration>")
@lock(TESTLOCK)
def locktest(duration):
    sleep(int(duration))
    return duration, 200


def make_new_player(username, password, **kwargs):
    user = {'Username': username,
            'Password': password,
            "Played": 0,
            "Won": 0,
            "Games": ["none", "none", "none", "none", "none"],
            "count_character_has_won": {l: 0 for l in CHARACTER_ORDERING},
            "count_character_has_been_played": {l: 0 for l in CHARACTER_ORDERING},
            'accepting_games': True,
            'skill_points': 0,
            'badge_progressions': [0] * BADGE_INFO_SPACES,
            'last_logged_in': datetime.now(),
            'elo': ELO_DEFAULT
            }

    user.update(kwargs)
    register(user)


def update_active_users_list(player, post=True):
    '''
    Updates the list of active users.
    Defaults to replacing the document in the database directly.
    Returns the dictionary containing the list of active users in the db (keys 'active_user_list', 'skill_points' and 'active_users', the latter being the set of recently active users' by usernames.)
    '''

    active_users = special_data.find_one({"active_user_list": True})
    if active_users is None:
        return "Could not find active users list in database", 500

    # If the user is already in the active_users list, remove them so that, when we add them, we add them to the top.
    if player['Username'] in active_users['active_users']:
        player_index = active_users['active_users'].index(player['Username'])
        active_users['active_users'].pop(player_index)
        active_users['skill_points'].pop(player_index)
        active_users['times_active'].pop(player_index)

        active_users['active_users'] = [player['Username']] + active_users['active_users']
        active_users['skill_points'] = [player['skill_points']] + active_users['skill_points']
        active_users['times_active'] = [datetime.now()] + active_users['times_active']
    
    else:
        active_users['active_users'] = [player['Username']] + active_users['active_users'][:-1]
        active_users['skill_points'] = [player['skill_points']] + active_users['skill_points'][:-1]
        active_users['times_active'] = [datetime.now()] + active_users['times_active'][:-1]

    if post:
        special_data.replace_one({'active_user_list': True}, active_users)

    return active_users


@app.route('/konami_code/<username>')
def konami_code(username):
    user = players.find_one({"Username": username})
    if user is None:
        return "Well done finding our konami code, " + username + "!"
    
    return "Well done finding our konami code, " + username + "! Your elo is currently " + str(user['elo']) + '.', 200



@app.route("/active_user_list/<username>")
@app.route("/active_user_list")
def get_active_user_list(username=None):
    active_users = special_data.find_one({"active_user_list": True})
    if active_users is not None:
    
        # Strip out the user looking at the active users, or the lease recent active user it it isn't supplied.
        to_pop = active_users['active_users'].index(username) if username and username in active_users['active_users'] else len(active_users['active_users'])-1
        active_users['active_users'].pop(to_pop)
        active_users['skill_points'].pop(to_pop)
        active_users['times_active'].pop(to_pop)

        del active_users['_id']
        return active_users, 200
    else:
        return "Could not get active users!", 500


def make_special_values():
    # Make new player list
    if players.find_one({"new_users": True}) is None:
        print("Making new users")
        players.insert_one({"new_users": True,
                            "users": [['none', None]] * 5})

    if special_data.find_one({"active_user_list": True}) is None:
        print("Making active users list")
        special_data.insert_one({"active_user_list": True,
                                 "active_users": ['none'] * 6,
                                 "skill_points": [0] * 6,
                                 "times_active": [None] * 6})

    # Make challenger list
    if players.find_one({"challengee_list": True}) is None:
        print("Making challegers")
        players.insert_one({"challengee_list": True,
                            "challengees": [['none', 'none']] * 5})

    # Make waiting
    if players.find_one({"waiting_list": True}) is None:
        print("Making waiting list")
        players.insert_one({"waiting_list": True, "waiting": None, "slot": None})

    # Make locks
    if players.find_one({"mutex_lock": True}) is None:
        print("Making locks")
        players.insert_one({"mutex_lock": True,
                            "locked_by": None,
                            "specific_locks": [None] * 50,
                            "default_lock": None})

    # Make MOTDs
    if special_data.find_one({"messages": {"$exists": True}}) is None:
        print("Making MOTDs")
        special_data.insert_one({"messages": [["Thanks for playing RPGLite!", []]]})

    # Make password reset keys
    if special_data.find_one({"password_reset_keys": True}) is None:
        print("Making password resets")
        special_data.insert_one({"password_reset_keys": True})



if __name__ == "__main__":
    # Backup job
    cron = BackgroundScheduler(daemon=True)
    cron.add_job(func=back_up, trigger='interval', seconds=BACKUP_FREQUENCY_SECS)
    cron.start()
    atexit.register(lambda: cron.shutdown())

    app.run(host="0.0.0.0", port=443)
